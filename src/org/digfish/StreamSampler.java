package org.digfish;

import java.util.ArrayList;
import java.util.Random;

/**
 * Created by sam on 07-03-2017.
 */
public class StreamSampler {


	private String toMB(double val) {
		if (val > 1024 * 1024) {
			long mb = Math.round(val / Math.pow(1024, 2));
			return mb + " MB";
		} else {
			return (int) val + " bytes";
		}
	}

	/**
	 * returns UNIX time in milliseconds
	 * @return
	 */
	private long now() {
		return System.currentTimeMillis();
	}

	/**
	 * returns a byte array containing random-generated bytes
	 * using the Random.ints method
	 * @param length
	 * @return
	 */
	private byte[] generateRandomChars(int length) {
		Random random = new Random();
		int[] rand_ints = random.ints(length, 32, Byte.MAX_VALUE).toArray();
		byte[] rand_bytes = new byte[rand_ints.length];
		for (int i = 0; i < rand_ints.length; i++) {
			rand_bytes[i] = (byte) rand_ints[i];
		}
		return rand_bytes;
	}
	
	/* instance variables */
	boolean usingInternalRandomSource = false;
	int megs = -1;
	int sampleSize = -1;
	
	// we assume a BUFFER SIZE of 8192 since is the record size most usual in
	// the majority of the filesystems nowadays, eg NTFS
	
	final int BUFFER_SIZE = 8192;

	/* one-arg constructor, used for processing stdin through piping */
	public StreamSampler(int sampleSize) {
		this(sampleSize, false, -1);
	}

	/* three-args constructor, using a JAVA internal generator */
	public StreamSampler(int sampleSize, boolean usingInternalRandomSource, int megs) {
		this.usingInternalRandomSource = usingInternalRandomSource;
		this.megs = megs;
		this.sampleSize = sampleSize;
	}

	/* main method, receives the generated data and stores it in data structure (ArrayList),
	 * later it picks random bytes from it to build the sample of the specified size 
	 */
	
	public String sampleIt() {

		long total_chars_read = 0;
		ArrayList<byte[]> holder = new ArrayList<byte[]>();

		long before = now();

		try {

			byte[] bbuf = null;
			int qty_chars_read = -1;

			if (usingInternalRandomSource) {
				int chunks = megs * (1024 * 1024) / BUFFER_SIZE;
				for (int i = 0; i < chunks; i++) {
					bbuf = generateRandomChars(BUFFER_SIZE);
					holder.add(bbuf);
					qty_chars_read = bbuf.length;
					total_chars_read += qty_chars_read;
					System.out.printf("\rTotal data read: %10s   ", toMB(total_chars_read));
				}
			} else {
				bbuf = new byte[BUFFER_SIZE];
				// reading bytes from the stdin

				while ((qty_chars_read = System.in.read(bbuf)) > 0) {
					total_chars_read += qty_chars_read;
					System.out.printf("\rTotal data read: %10s   ", toMB(total_chars_read));
					holder.add(bbuf);
				}
			}

		} catch (Exception e) {
			e.printStackTrace();
		}

		long after = now();

		System.out.println();


		// now that we have a arraylist containing all the contents of the
		// stream, we can sample it extracting random bytes
		// at will
		
		StringBuffer rep_set = new StringBuffer(sampleSize);
		Random random = new Random();
		for (int i = 0; i < sampleSize; i++) {
			int random_int = random.nextInt(holder.size());
			String str = new String((byte[]) holder.get(random_int));
			char c = str.charAt(random.nextInt(str.length()));
			rep_set.append(c);
		}
		
		System.out.println(toMB(total_chars_read) + " total where read from stdin!");
		System.out.println("Total time processing: " + (after - before) / 1000 + " s");

		return rep_set.toString();

	}

}
